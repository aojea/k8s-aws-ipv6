---
AWSTemplateFormatVersion: '2010-09-09'
Description: VPC-IPv6-K8S

Resources:
  # VPC-IPv6-K8S
  K8sIPv6Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 192.168.0.0/16
      InstanceTenancy: default
      Tags:
      - Key: Name
        Value: K8sIPv6VPC
  IPv6CidrBlock:
    Type: AWS::EC2::VPCCidrBlock
    Properties:
      VpcId: !Ref K8sIPv6Vpc
      AmazonProvidedIpv6CidrBlock: true
  # Internet gateway
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: K8sIPv6IG
  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: !Ref K8sIPv6Vpc
      InternetGatewayId: !Ref InternetGateway
  # Routing - public subnets
  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref K8sIPv6Vpc
      Tags:
      - Key: Name
        Value: K8sIPv6RT
  PublicSubnetDefaultRoute:
    DependsOn: InternetGatewayAttachment
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      RouteTableId: !Ref PublicSubnetRouteTable
      GatewayId: !Ref InternetGateway
  PublicSubnetDefaultIpv6Route:
    Type: AWS::EC2::Route
    Properties:
      DestinationIpv6CidrBlock: ::/0
      RouteTableId: !Ref PublicSubnetRouteTable
      GatewayId: !Ref InternetGateway

  # Access control
  PublicSubnetsNetworkAcl:
    Type: AWS::EC2::NetworkAcl
    Properties:
      VpcId: !Ref K8sIPv6Vpc
      Tags:
      - Key: Name
        Value: K8sIPv6SubnetACL
  PublicSubnetsNetworkAclSSHInboundEntry:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref PublicSubnetsNetworkAcl
      RuleNumber: 1
      PortRange:
        From: 22 # SSH
        To: 22
      Protocol: 6 # TCP
      RuleAction: allow
      Egress: false
      Ipv6CidrBlock: ::/0
  PublicSubnetsNetworkAclAPIInboundEntry:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref PublicSubnetsNetworkAcl
      RuleNumber: 2
      PortRange:
        From: 6443 # SSH
        To: 6443
      Protocol: 6 # TCP
      RuleAction: allow
      Egress: false
      Ipv6CidrBlock: ::/0
  PublicSubnetsNetworkAclULAInboundEntry:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref PublicSubnetsNetworkAcl
      RuleNumber: 3
      Protocol: -1 # All
      RuleAction: allow
      Egress: false
      Ipv6CidrBlock: fd00::/8
  PublicSubnetsNetworkAclIpv6OutboundEntry:
    Type: AWS::EC2::NetworkAclEntry
    Properties:
      NetworkAclId: !Ref PublicSubnetsNetworkAcl
      RuleNumber: 1
      Protocol: -1
      RuleAction: allow
      Egress: true
      Ipv6CidrBlock: ::/0

  # Public subnet A
  PublicSubnetA:
    Type: AWS::EC2::Subnet
    DependsOn: IPv6CidrBlock
    Properties:
      CidrBlock: 192.168.0.0/24
      Ipv6CidrBlock:
        Fn::Sub:
          - "${VpcPart}${SubnetPart}"
          - SubnetPart: '01::/64'
            VpcPart: !Select [ 0, !Split [ '00::/56', !Select [ 0, !GetAtt K8sIPv6Vpc.Ipv6CidrBlocks ]]]
      AvailabilityZone: !Select [ 0, !GetAZs '' ]
      VpcId: !Ref K8sIPv6Vpc
      AssignIpv6AddressOnCreation: 'true'
      Tags:
      - Key: Name
        Value: K8sIPv6Subnet
  PublicSubnetARouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicSubnetRouteTable
      SubnetId: !Ref PublicSubnetA
  PublicSubnetAAclAssociation:
    Type: AWS::EC2::SubnetNetworkAclAssociation
    Properties:
      NetworkAclId: !Ref PublicSubnetsNetworkAcl
      SubnetId: !Ref PublicSubnetA

  MasterHost:
    Type: AWS::EC2::Instance
    Metadata:
      AWS::CloudFormation::Init:
        configSets:
          master-setup: master-setup
        master-setup:
          files:
            # Script that will allow for development kubernetes binaries to replace the pre-packaged AMI binaries.
            "/tmp/kubeadm.yaml":
              content: !Sub |
                ---
                apiVersion: kubeadm.k8s.io/v1beta2
                kind: ClusterConfiguration
                clusterName: ipv6-cluster
                apiServer:
                  extraArgs:
                    bind-address: "::"
                controllerManager:
                  extraArgs:
                    configure-cloud-routes: "false"
                    bind-address: "::"
                kubernetesVersion: v1.17.3
                networking:
                  podSubnet: fd00:10:244::/64
                  serviceSubnet: fd00:10:96::/112
                scheduler:
                  extraArgs:
                    address: "::"
                    bind-address: "::1"
                ---
                apiVersion: kubeadm.k8s.io/v1beta2
                kind: InitConfiguration
                metadata:
                  name: config
                # we use a well know token for TLS bootstrap
                bootstrapTokens:
                - token: abcdef.0123456789abcdef
                # we use a well know port for making the API server discoverable inside docker network.
                # from the host machine such port will be accessible via a random local port instead.
                localAPIEndpoint:
                  bindPort: 6443
                nodeRegistration:
                  kubeletExtraArgs:
                    fail-swap-on: "false"
                    node-ip: "::"
                ---
                apiVersion: kubelet.config.k8s.io/v1beta1
                kind: KubeletConfiguration
                metadata:
                  name: config
                # configure ipv6 addresses in IPv6 mode
                address: "::"
                healthzBindAddress: "::"
                # disable disk resource management by default
                # kubelet will see the host disk that the inner container runtime
                # is ultimately backed by and attempt to recover disk space. we don't want that.
                imageGCHighThresholdPercent: 100
                evictionHard:
                  nodefs.available: "0%"
                  nodefs.inodesFree: "0%"
                  imagefs.available: "0%"
          commands:
            # Override the AMI binaries with any kubelet/kubeadm/kubectl binaries in the S3 bucket
            "00-kubeadm-init":
              command: "kubeadm init --config /tmp/kubeadm.yaml --ignore-preflight-errors=all -v7"
    Properties:
      ImageId: ami-0c99fe0adb531276d # Full baked image with all the needed components
      SourceDestCheck: false # We need to route pod and services traffic inside the instances
      InstanceType: t2.micro # TODO parameter
      NetworkInterfaces:
      - AssociatePublicIpAddress: true
        DeleteOnTermination: true
        DeviceIndex: 0
        SubnetId: !Ref PublicSubnet
        # This address is chosen because we know the master always
        Ipv6Addresses:
          Fn::Sub:
            - "${SubnetPart}${HostPart}"
            - HostPart: '::aa/128'
              SubnetPart: !Select [ 0, !Split [ '01::/64', !Select [ 0, !GetAtt PublicSubnetA.Ipv6CidrBlocks ]]]
      Tags:
      - Key: Name
        Value: master-host
      KeyName: aojeagarcia-key # TODO parameter

  # Define the (one) security group for all machines in the cluster.  Keeping
  # just one security group helps with k8s's cloud-provider=aws integration so
  # that it knows what security group to manage.
  ClusterSecGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for all machines in the cluster
      VpcId: !Ref VPCID
      # Security Groups must be tagged with KubernetesCluster=<cluster> so that
      # they can coexist in the same VPC
      Tags:
      - Key: Name
        Value: k8s-cluster-security-group

  # Permissions we add to the main security group:
  # - Ensure cluster machines can talk to one another
  ClusterSecGroupCrossTalk:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ClusterSecGroup
      SourceSecurityGroupId: !Ref ClusterSecGroup
      IpProtocol: '-1'
      FromPort: '0'
      ToPort: '65535'

  # - Open up port 22 for SSH into each machine
  # The allowed locations are chosen by the user in the SSHLocation parameter
  ClusterSecGroupAllow22:
    Metadata:
      Comment: Open up port 22 for SSH into each machine
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ClusterSecGroup
      IpProtocol: tcp
      FromPort: '22'
      ToPort: '22'

  # Allow the apiserver load balancer to talk to the cluster on port 6443
  ClusterSecGroupAllow6443:
    Metadata:
      Comment: Open up port 6443 for load balancing the API server
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      GroupId: !Ref ClusterSecGroup
      IpProtocol: tcp
      FromPort: '6443'
      ToPort: '6443'
